---
// NextMatch.astro - Zeigt das n√§chste Ligaspiel dynamisch von der 2K API
const { small = false } = Astro.props;
const TEAM_ID = 308868; // SCO-Darts Team F√ºlltreffer
const TEAM_NAME = "SCO-Darts Team F√ºlltreffer";
---

<div class={`next-match-container ${small ? 'block w-full' : 'bg-white rounded-lg px-4 py-3 border border-slate-300'}`} data-small={small}>
    {/* Standard View */}
    {!small && (
      <>
      <div class="flex gap-2 justify-between items-center mb-2">
          <h2 class="font-bold">N√§chstes Ligaspiel</h2>
          <span class="home-away-badge text-xs py-1 px-2 rounded-full hidden"></span>
      </div>
      <hr class="mb-3" />
      </>
    )}
  
      <div class="next-match-content">
          <div class="loading-state py-4 text-center text-slate-500">
               {small ? (
                  <span class="animate-pulse text-xs">...</span>
               ) : (
                  <>
                  <svg
                      class="animate-spin h-5 w-5 mx-auto mb-2"
                      xmlns="http://www.w3.org/2000/svg"
                      fill="none"
                      viewBox="0 0 24 24"
                  >
                      <circle
                          class="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          stroke-width="4"></circle>
                      <path
                          class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      ></path>
                  </svg>
                  Lade Spielplan...
                  </>
               )}
          </div>
  
          <div class="match-info hidden">
              {small ? (
                <div class="flex items-center justify-center w-full gap-4 px-4 py-2">
                   <div class="flex items-center gap-2 text-slate-700">
                      <span class="home-away-badge text-[10px] uppercase tracking-wider py-0.5 px-2 rounded-full hidden font-bold"></span>
                      <div class="flex items-center gap-1.5 leading-none">
                        <span class="font-bold date-short text-xs"></span>
                        <span class="text-slate-400 text-xs">vs</span>
                        <span class="opponent-team font-semibold truncate max-w-[200px] text-xs"></span>
                      </div>
                   </div>
                </div>
              ) : (
              <div class="flex flex-col gap-2">
                  <!-- Datum und Uhrzeit -->
                  <div class="flex items-center gap-2">
                      <span
                          class="date-badge text-xs font-semibold py-1 px-2 rounded-full bg-slate-100"
                      ></span>
                      <span class="time-text text-sm text-slate-600"></span>
                  </div>
  
                  <!-- Teams -->
                  <div class="flex flex-col gap-1 mt-1">
                      <div
                          class="flex items-center justify-between gap-2 text-sm"
                      >
                          <span class="home-team font-semibold flex-1 truncate"
                          ></span>
                          <span class="text-slate-400">vs</span>
                          <span
                              class="guest-team font-semibold flex-1 truncate text-right"
                          ></span>
                      </div>
                  </div>
  
                  <!-- Spieltag Info -->
                  <div class="text-xs text-slate-500 mt-1">
                      <span class="round-name"></span>
                  </div>
              </div>
              )}
          </div>
  
          <div class="no-match-state hidden py-4 text-center text-slate-500">
              {small ? '' : 'Kein anstehendes Spiel gefunden'}
          </div>
  
          <div class="error-state hidden py-4 text-center text-red-500">
               {small ? '!' : 'Fehler beim Laden der Daten'}
          </div>
      </div>
  </div>
  
  <script define:vars={{ TEAM_ID, TEAM_NAME }}>
  (function() {
      const API_BASE = "https://backend4.2k-dart-software.com/2k-backend4/api/v1/frontend";
      const EVENT_ID = 15995;
      const PHASE_ID = 26752;
      const CACHE_KEY = "sco_next_match_v1";
      const CACHE_DURATION = 1000 * 60 * 15; // 15 minutes

      async function initNextMatch(container) {
          if (container.dataset.initialized) return;
          container.dataset.initialized = "true";
          
          const isSmall = container.hasAttribute('data-small');
          const loadingEl = container.querySelector(".loading-state");
          const matchInfoEl = container.querySelector(".match-info");
          const noMatchEl = container.querySelector(".no-match-state");
          const errorEl = container.querySelector(".error-state");
          const badgeEl = container.querySelector(".home-away-badge");

          // Helper to update UI
          const updateUI = (data) => {
              const { isHome, opponent, homeTeam, guestTeam, formattedDate, formattedTime, roundName } = data;
              
                loadingEl.classList.add("hidden");
                matchInfoEl.classList.remove("hidden");
    
                // Heim/Ausw√§rts Badge
                if (badgeEl) {
                    const badgeText = isHome ? "Heimspiel" : "Ausw√§rts";
                    badgeEl.textContent = isSmall ? `üéØ ${badgeText}` : (isHome ? "üè† Heimspiel" : "üöó Ausw√§rts");
                    
                    if (isSmall) {
                        badgeEl.className = `home-away-badge text-[10px] uppercase tracking-wider py-0.5 px-2 rounded-full mr-1 ${isHome ? "bg-green-100 text-green-800 border border-green-200" : "bg-blue-100 text-blue-800 border border-blue-200"}`;
                    } else {
                        badgeEl.className = `home-away-badge text-xs py-1 px-2 rounded-full ${isHome ? "bg-green-100 text-green-800" : "bg-blue-100 text-blue-800"}`;
                    }
                    badgeEl.classList.remove("hidden");
                }
    
                if (isSmall) {
                    const dateShortEl = matchInfoEl.querySelector('.date-short');
                    const opponentEl = matchInfoEl.querySelector('.opponent-team');
                    if(dateShortEl) dateShortEl.textContent = `${formattedDate}, ${formattedTime.split(' ')[0]}`;
                    if(opponentEl) opponentEl.textContent = opponent;
                } else {
                    // ... populate normal view ...
                    matchInfoEl.querySelector(".date-badge").textContent = formattedDate;
                    matchInfoEl.querySelector(".time-text").textContent = formattedTime;
    
                    const homeEl = matchInfoEl.querySelector(".home-team");
                    const guestEl = matchInfoEl.querySelector(".guest-team");
                    homeEl.textContent = homeTeam;
                    guestEl.textContent = guestTeam;
    
                    if (isHome) {
                        homeEl.classList.add("text-red-700", "font-bold");
                    } else {
                        guestEl.classList.add("text-red-700", "font-bold");
                    }
    
                    matchInfoEl.querySelector(".round-name").textContent = roundName;
                }
          };
  
          try {
              // 1. Check Session Cache
              const cached =  sessionStorage.getItem(CACHE_KEY);
              if (cached) {
                  const { timestamp, data } = JSON.parse(cached);
                  if (Date.now() - timestamp < CACHE_DURATION) {
                      updateUI(data);
                      return; // Early exit with cache
                  }
              }

              // 2. Fetch Data if no cache or expired
              // Wir cachen den Fetch Request f√ºr Phase daten, damit wir nicht 2x fetchen wenn Header und Body Component da sind
              if (!window.phaseDataCache) {
                 window.phaseDataCache = fetch(`${API_BASE}/event/${EVENT_ID}/phase/${PHASE_ID}`).then(r => r.json());
              }
              const phaseData = await window.phaseDataCache;
       
            // 3. Finde das n√§chste Spiel nach Match-Datum (nicht nur nach Rundendatum)
            const now = new Date();
            const startOfToday = new Date();
            startOfToday.setHours(0, 0, 0, 0);

            const roundsByDate = [...phaseData.rounds].sort(
                (a, b) => new Date(a.dateFrom) - new Date(b.dateFrom)
            );

            // 4. Durchsuche die Runden nach unserem n√§chsten Spiel
            let foundMatch = null;
            let foundRound = null;
            let fallbackMatch = null;
            let fallbackRound = null;

            for (const round of roundsByDate) {
                  // Cache round requests auch
                   const cacheKey = `round_${round.id}`;
                   if (!window[cacheKey]) {
                        window[cacheKey] = fetch(`${API_BASE}/event/${EVENT_ID}/phase/${PHASE_ID}/round/${round.id}`).then(r => r.json());
                   }
                  const roundData = await window[cacheKey];
  
                  // Suche unser Match
                const ourMatches = roundData.matches.filter(
                    (match) =>
                        match.participantHome?.id === TEAM_ID ||
                        match.participantGuest?.id === TEAM_ID,
                );

                if (ourMatches.length === 0) continue;

                // Kandidat: n√§chstes Spiel ab heute
                const upcomingMatch = ourMatches
                    .filter((match) => match.statusCd !== "FINISHED")
                    .map((match) => ({
                        match,
                        date: match.datePlanned ? new Date(match.datePlanned) : null,
                    }))
                    .filter((item) => item.date && item.date >= startOfToday)
                    .sort((a, b) => a.date - b.date)[0];

                if (upcomingMatch) {
                    foundMatch = upcomingMatch.match;
                    foundRound = round;
                    break;
                }

                // Fallback: erstes nicht beendetes Match, falls keine DatePlanned >= heute
                const firstNotFinished = ourMatches.find(
                    (match) => match.statusCd !== "FINISHED",
                );
                if (firstNotFinished && !fallbackMatch) {
                    fallbackMatch = firstNotFinished;
                    fallbackRound = round;
                }
              }
  
            if (!foundMatch && fallbackMatch) {
                foundMatch = fallbackMatch;
                foundRound = fallbackRound;
            }

            if (!foundMatch) {
                  loadingEl.classList.add("hidden");
                  if(noMatchEl) noMatchEl.classList.remove("hidden");
                  return;
              }
  
              // 5. Match-Daten extrahieren & Cachen
              const isHome = foundMatch.participantHome?.id === TEAM_ID;
              const opponent = isHome
                  ? foundMatch.participantGuest?.displayName
                  : foundMatch.participantHome?.displayName;
              const homeTeam = foundMatch.participantHome?.displayName || "TBD";
              const guestTeam = foundMatch.participantGuest?.displayName || "TBD";
  
              // Datum formatieren
              const matchDate = new Date(foundMatch.datePlanned);
              const dateOptions = {
                  weekday: "short",
                  day: "2-digit",
                  month: "2-digit",
              };
              const timeOptions = { hour: "2-digit", minute: "2-digit" };
              const formattedDate = matchDate.toLocaleDateString(
                  "de-DE",
                  dateOptions,
              );
              const formattedTime =
                  matchDate.toLocaleTimeString("de-DE", timeOptions) + " Uhr";

              const matchInfoData = {
                  isHome,
                  opponent,
                  homeTeam,
                  guestTeam,
                  formattedDate,
                  formattedTime,
                  roundName: foundRound.name
              };
              
              // Save to cache
              sessionStorage.setItem(CACHE_KEY, JSON.stringify({
                  timestamp: Date.now(),
                  data: matchInfoData
              }));

              // 6. UI aktualisieren
              updateUI(matchInfoData);
  
          } catch (error) {
               console.error("Error fetching next match:", error);
              loadingEl.classList.add("hidden");
              if(errorEl) errorEl.classList.remove("hidden");
          }
      }
  
      // Run for all instances
      document.querySelectorAll('.next-match-container').forEach(initNextMatch);
  })();
  </script>